{
  "version": 3,
  "sources": ["../../../../../../node_modules/hammerjs/hammer.js", "../../../../../../node_modules/chartjs-plugin-zoom/dist/chartjs-plugin-zoom.esm.js"],
  "sourcesContent": ["/*! Hammer.JS - v2.0.7 - 2016-04-22\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2016 Jorik Tangelder;\n * Licensed under the MIT license */\n(function (window, document, exportName, undefined) {\n  'use strict';\n\n  var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\n  var TEST_ELEMENT = document.createElement('div');\n  var TYPE_FUNCTION = 'function';\n  var round = Math.round;\n  var abs = Math.abs;\n  var now = Date.now;\n\n  /**\n   * set a timeout with a given scope\n   * @param {Function} fn\n   * @param {Number} timeout\n   * @param {Object} context\n   * @returns {number}\n   */\n  function setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n  }\n\n  /**\n   * if the argument is an array, we want to execute the fn on each entry\n   * if it aint an array we don't want to do a thing.\n   * this is used by all the methods that accept a single and array argument.\n   * @param {*|Array} arg\n   * @param {String} fn\n   * @param {Object} [context]\n   * @returns {Boolean}\n   */\n  function invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n      each(arg, context[fn], context);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * walk objects and arrays\n   * @param {Object} obj\n   * @param {Function} iterator\n   * @param {Object} context\n   */\n  function each(obj, iterator, context) {\n    var i;\n    if (!obj) {\n      return;\n    }\n    if (obj.forEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length !== undefined) {\n      i = 0;\n      while (i < obj.length) {\n        iterator.call(context, obj[i], i, obj);\n        i++;\n      }\n    } else {\n      for (i in obj) {\n        obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n      }\n    }\n  }\n\n  /**\n   * wrap a method with a deprecation warning and stack trace\n   * @param {Function} method\n   * @param {String} name\n   * @param {String} message\n   * @returns {Function} A new function wrapping the supplied method.\n   */\n  function deprecate(method, name, message) {\n    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n    return function () {\n      var e = new Error('get-stack-trace');\n      var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '').replace(/^\\s+at\\s+/gm, '').replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n      var log = window.console && (window.console.warn || window.console.log);\n      if (log) {\n        log.call(window.console, deprecationMessage, stack);\n      }\n      return method.apply(this, arguments);\n    };\n  }\n\n  /**\n   * extend object.\n   * means that properties in dest will be overwritten by the ones in src.\n   * @param {Object} target\n   * @param {...Object} objects_to_assign\n   * @returns {Object} target\n   */\n  var assign;\n  if (typeof Object.assign !== 'function') {\n    assign = function assign(target) {\n      if (target === undefined || target === null) {\n        throw new TypeError('Cannot convert undefined or null to object');\n      }\n      var output = Object(target);\n      for (var index = 1; index < arguments.length; index++) {\n        var source = arguments[index];\n        if (source !== undefined && source !== null) {\n          for (var nextKey in source) {\n            if (source.hasOwnProperty(nextKey)) {\n              output[nextKey] = source[nextKey];\n            }\n          }\n        }\n      }\n      return output;\n    };\n  } else {\n    assign = Object.assign;\n  }\n\n  /**\n   * extend object.\n   * means that properties in dest will be overwritten by the ones in src.\n   * @param {Object} dest\n   * @param {Object} src\n   * @param {Boolean} [merge=false]\n   * @returns {Object} dest\n   */\n  var extend = deprecate(function extend(dest, src, merge) {\n    var keys = Object.keys(src);\n    var i = 0;\n    while (i < keys.length) {\n      if (!merge || merge && dest[keys[i]] === undefined) {\n        dest[keys[i]] = src[keys[i]];\n      }\n      i++;\n    }\n    return dest;\n  }, 'extend', 'Use `assign`.');\n\n  /**\n   * merge the values from src in the dest.\n   * means that properties that exist in dest will not be overwritten by src\n   * @param {Object} dest\n   * @param {Object} src\n   * @returns {Object} dest\n   */\n  var merge = deprecate(function merge(dest, src) {\n    return extend(dest, src, true);\n  }, 'merge', 'Use `assign`.');\n\n  /**\n   * simple class inheritance\n   * @param {Function} child\n   * @param {Function} base\n   * @param {Object} [properties]\n   */\n  function inherit(child, base, properties) {\n    var baseP = base.prototype,\n      childP;\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n    if (properties) {\n      assign(childP, properties);\n    }\n  }\n\n  /**\n   * simple function bind\n   * @param {Function} fn\n   * @param {Object} context\n   * @returns {Function}\n   */\n  function bindFn(fn, context) {\n    return function boundFn() {\n      return fn.apply(context, arguments);\n    };\n  }\n\n  /**\n   * let a boolean value also be a function that must return a boolean\n   * this first item in args will be used as the context\n   * @param {Boolean|Function} val\n   * @param {Array} [args]\n   * @returns {Boolean}\n   */\n  function boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n      return val.apply(args ? args[0] || undefined : undefined, args);\n    }\n    return val;\n  }\n\n  /**\n   * use the val2 when val1 is undefined\n   * @param {*} val1\n   * @param {*} val2\n   * @returns {*}\n   */\n  function ifUndefined(val1, val2) {\n    return val1 === undefined ? val2 : val1;\n  }\n\n  /**\n   * addEventListener with multiple events at once\n   * @param {EventTarget} target\n   * @param {String} types\n   * @param {Function} handler\n   */\n  function addEventListeners(target, types, handler) {\n    each(splitStr(types), function (type) {\n      target.addEventListener(type, handler, false);\n    });\n  }\n\n  /**\n   * removeEventListener with multiple events at once\n   * @param {EventTarget} target\n   * @param {String} types\n   * @param {Function} handler\n   */\n  function removeEventListeners(target, types, handler) {\n    each(splitStr(types), function (type) {\n      target.removeEventListener(type, handler, false);\n    });\n  }\n\n  /**\n   * find if a node is in the given parent\n   * @method hasParent\n   * @param {HTMLElement} node\n   * @param {HTMLElement} parent\n   * @return {Boolean} found\n   */\n  function hasParent(node, parent) {\n    while (node) {\n      if (node == parent) {\n        return true;\n      }\n      node = node.parentNode;\n    }\n    return false;\n  }\n\n  /**\n   * small indexOf wrapper\n   * @param {String} str\n   * @param {String} find\n   * @returns {Boolean} found\n   */\n  function inStr(str, find) {\n    return str.indexOf(find) > -1;\n  }\n\n  /**\n   * split string on whitespace\n   * @param {String} str\n   * @returns {Array} words\n   */\n  function splitStr(str) {\n    return str.trim().split(/\\s+/g);\n  }\n\n  /**\n   * find if a array contains the object using indexOf or a simple polyFill\n   * @param {Array} src\n   * @param {String} find\n   * @param {String} [findByKey]\n   * @return {Boolean|Number} false when not found, or the index\n   */\n  function inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n      return src.indexOf(find);\n    } else {\n      var i = 0;\n      while (i < src.length) {\n        if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {\n          return i;\n        }\n        i++;\n      }\n      return -1;\n    }\n  }\n\n  /**\n   * convert array-like objects to real arrays\n   * @param {Object} obj\n   * @returns {Array}\n   */\n  function toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n  }\n\n  /**\n   * unique array with objects based on a key (like 'id') or just by the array's value\n   * @param {Array} src [{id:1},{id:2},{id:1}]\n   * @param {String} [key]\n   * @param {Boolean} [sort=False]\n   * @returns {Array} [{id:1},{id:2}]\n   */\n  function uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n    while (i < src.length) {\n      var val = key ? src[i][key] : src[i];\n      if (inArray(values, val) < 0) {\n        results.push(src[i]);\n      }\n      values[i] = val;\n      i++;\n    }\n    if (sort) {\n      if (!key) {\n        results = results.sort();\n      } else {\n        results = results.sort(function sortUniqueArray(a, b) {\n          return a[key] > b[key];\n        });\n      }\n    }\n    return results;\n  }\n\n  /**\n   * get the prefixed property\n   * @param {Object} obj\n   * @param {String} property\n   * @returns {String|Undefined} prefixed\n   */\n  function prefixed(obj, property) {\n    var prefix, prop;\n    var camelProp = property[0].toUpperCase() + property.slice(1);\n    var i = 0;\n    while (i < VENDOR_PREFIXES.length) {\n      prefix = VENDOR_PREFIXES[i];\n      prop = prefix ? prefix + camelProp : property;\n      if (prop in obj) {\n        return prop;\n      }\n      i++;\n    }\n    return undefined;\n  }\n\n  /**\n   * get a unique id\n   * @returns {number} uniqueId\n   */\n  var _uniqueId = 1;\n  function uniqueId() {\n    return _uniqueId++;\n  }\n\n  /**\n   * get the window object of an element\n   * @param {HTMLElement} element\n   * @returns {DocumentView|Window}\n   */\n  function getWindowForElement(element) {\n    var doc = element.ownerDocument || element;\n    return doc.defaultView || doc.parentWindow || window;\n  }\n  var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n  var SUPPORT_TOUCH = 'ontouchstart' in window;\n  var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\n  var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n  var INPUT_TYPE_TOUCH = 'touch';\n  var INPUT_TYPE_PEN = 'pen';\n  var INPUT_TYPE_MOUSE = 'mouse';\n  var INPUT_TYPE_KINECT = 'kinect';\n  var COMPUTE_INTERVAL = 25;\n  var INPUT_START = 1;\n  var INPUT_MOVE = 2;\n  var INPUT_END = 4;\n  var INPUT_CANCEL = 8;\n  var DIRECTION_NONE = 1;\n  var DIRECTION_LEFT = 2;\n  var DIRECTION_RIGHT = 4;\n  var DIRECTION_UP = 8;\n  var DIRECTION_DOWN = 16;\n  var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\n  var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\n  var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n  var PROPS_XY = ['x', 'y'];\n  var PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n  /**\n   * create new input type manager\n   * @param {Manager} manager\n   * @param {Function} callback\n   * @returns {Input}\n   * @constructor\n   */\n  function Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.domHandler = function (ev) {\n      if (boolOrFn(manager.options.enable, [manager])) {\n        self.handler(ev);\n      }\n    };\n    this.init();\n  }\n  Input.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function () {},\n    /**\n     * bind the events\n     */\n    init: function () {\n      this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n      this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n      this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    },\n    /**\n     * unbind the events\n     */\n    destroy: function () {\n      this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n      this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n      this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n  };\n\n  /**\n   * create new input type manager\n   * called by the Manager constructor\n   * @param {Hammer} manager\n   * @returns {Input}\n   */\n  function createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n    if (inputClass) {\n      Type = inputClass;\n    } else if (SUPPORT_POINTER_EVENTS) {\n      Type = PointerEventInput;\n    } else if (SUPPORT_ONLY_TOUCH) {\n      Type = TouchInput;\n    } else if (!SUPPORT_TOUCH) {\n      Type = MouseInput;\n    } else {\n      Type = TouchMouseInput;\n    }\n    return new Type(manager, inputHandler);\n  }\n\n  /**\n   * handle input events\n   * @param {Manager} manager\n   * @param {String} eventType\n   * @param {Object} input\n   */\n  function inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n    var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n    if (isFirst) {\n      manager.session = {};\n    }\n\n    // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n    input.eventType = eventType;\n\n    // compute scale, rotation etc\n    computeInputData(manager, input);\n\n    // emit secret event\n    manager.emit('hammer.input', input);\n    manager.recognize(input);\n    manager.session.prevInput = input;\n  }\n\n  /**\n   * extend the data with some usable properties like scale, rotate, velocity etc\n   * @param {Object} manager\n   * @param {Object} input\n   */\n  function computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length;\n\n    // store the first input to calculate the distance and direction\n    if (!session.firstInput) {\n      session.firstInput = simpleCloneInputData(input);\n    }\n\n    // to compute scale and rotation we need to store the multiple touches\n    if (pointersLength > 1 && !session.firstMultiple) {\n      session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n      session.firstMultiple = false;\n    }\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n    var center = input.center = getCenter(pointers);\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n    input.overallVelocityX = overallVelocity.x;\n    input.overallVelocityY = overallVelocity.y;\n    input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n    input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;\n    computeIntervalInputData(session, input);\n\n    // find the correct target\n    var target = manager.element;\n    if (hasParent(input.srcEvent.target, target)) {\n      target = input.srcEvent.target;\n    }\n    input.target = target;\n  }\n  function computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n      prevDelta = session.prevDelta = {\n        x: prevInput.deltaX || 0,\n        y: prevInput.deltaY || 0\n      };\n      offset = session.offsetDelta = {\n        x: center.x,\n        y: center.y\n      };\n    }\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n  }\n\n  /**\n   * velocity is calculated every x ms\n   * @param {Object} session\n   * @param {Object} input\n   */\n  function computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n      deltaTime = input.timeStamp - last.timeStamp,\n      velocity,\n      velocityX,\n      velocityY,\n      direction;\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n      var deltaX = input.deltaX - last.deltaX;\n      var deltaY = input.deltaY - last.deltaY;\n      var v = getVelocity(deltaTime, deltaX, deltaY);\n      velocityX = v.x;\n      velocityY = v.y;\n      velocity = abs(v.x) > abs(v.y) ? v.x : v.y;\n      direction = getDirection(deltaX, deltaY);\n      session.lastInterval = input;\n    } else {\n      // use latest velocity info if it doesn't overtake a minimum period\n      velocity = last.velocity;\n      velocityX = last.velocityX;\n      velocityY = last.velocityY;\n      direction = last.direction;\n    }\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n  }\n\n  /**\n   * create a simple clone from the input used for storage of firstInput and firstMultiple\n   * @param {Object} input\n   * @returns {Object} clonedInputData\n   */\n  function simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need clientXY for the calculations\n    var pointers = [];\n    var i = 0;\n    while (i < input.pointers.length) {\n      pointers[i] = {\n        clientX: round(input.pointers[i].clientX),\n        clientY: round(input.pointers[i].clientY)\n      };\n      i++;\n    }\n    return {\n      timeStamp: now(),\n      pointers: pointers,\n      center: getCenter(pointers),\n      deltaX: input.deltaX,\n      deltaY: input.deltaY\n    };\n  }\n\n  /**\n   * get the center of all the pointers\n   * @param {Array} pointers\n   * @return {Object} center contains `x` and `y` properties\n   */\n  function getCenter(pointers) {\n    var pointersLength = pointers.length;\n\n    // no need to loop when only one touch\n    if (pointersLength === 1) {\n      return {\n        x: round(pointers[0].clientX),\n        y: round(pointers[0].clientY)\n      };\n    }\n    var x = 0,\n      y = 0,\n      i = 0;\n    while (i < pointersLength) {\n      x += pointers[i].clientX;\n      y += pointers[i].clientY;\n      i++;\n    }\n    return {\n      x: round(x / pointersLength),\n      y: round(y / pointersLength)\n    };\n  }\n\n  /**\n   * calculate the velocity between two points. unit is in px per ms.\n   * @param {Number} deltaTime\n   * @param {Number} x\n   * @param {Number} y\n   * @return {Object} velocity `x` and `y`\n   */\n  function getVelocity(deltaTime, x, y) {\n    return {\n      x: x / deltaTime || 0,\n      y: y / deltaTime || 0\n    };\n  }\n\n  /**\n   * get the direction between two points\n   * @param {Number} x\n   * @param {Number} y\n   * @return {Number} direction\n   */\n  function getDirection(x, y) {\n    if (x === y) {\n      return DIRECTION_NONE;\n    }\n    if (abs(x) >= abs(y)) {\n      return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n  }\n\n  /**\n   * calculate the absolute distance between two points\n   * @param {Object} p1 {x, y}\n   * @param {Object} p2 {x, y}\n   * @param {Array} [props] containing x and y keys\n   * @return {Number} distance\n   */\n  function getDistance(p1, p2, props) {\n    if (!props) {\n      props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n      y = p2[props[1]] - p1[props[1]];\n    return Math.sqrt(x * x + y * y);\n  }\n\n  /**\n   * calculate the angle between two coordinates\n   * @param {Object} p1\n   * @param {Object} p2\n   * @param {Array} [props] containing x and y keys\n   * @return {Number} angle\n   */\n  function getAngle(p1, p2, props) {\n    if (!props) {\n      props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n      y = p2[props[1]] - p1[props[1]];\n    return Math.atan2(y, x) * 180 / Math.PI;\n  }\n\n  /**\n   * calculate the rotation degrees between two pointersets\n   * @param {Array} start array of pointers\n   * @param {Array} end array of pointers\n   * @return {Number} rotation\n   */\n  function getRotation(start, end) {\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n  }\n\n  /**\n   * calculate the scale factor between two pointersets\n   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n   * @param {Array} start array of pointers\n   * @param {Array} end array of pointers\n   * @return {Number} scale\n   */\n  function getScale(start, end) {\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n  }\n  var MOUSE_INPUT_MAP = {\n    mousedown: INPUT_START,\n    mousemove: INPUT_MOVE,\n    mouseup: INPUT_END\n  };\n  var MOUSE_ELEMENT_EVENTS = 'mousedown';\n  var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n  /**\n   * Mouse events input\n   * @constructor\n   * @extends Input\n   */\n  function MouseInput() {\n    this.evEl = MOUSE_ELEMENT_EVENTS;\n    this.evWin = MOUSE_WINDOW_EVENTS;\n    this.pressed = false; // mousedown state\n\n    Input.apply(this, arguments);\n  }\n  inherit(MouseInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function MEhandler(ev) {\n      var eventType = MOUSE_INPUT_MAP[ev.type];\n\n      // on start we want to have the left mouse button down\n      if (eventType & INPUT_START && ev.button === 0) {\n        this.pressed = true;\n      }\n      if (eventType & INPUT_MOVE && ev.which !== 1) {\n        eventType = INPUT_END;\n      }\n\n      // mouse must be down\n      if (!this.pressed) {\n        return;\n      }\n      if (eventType & INPUT_END) {\n        this.pressed = false;\n      }\n      this.callback(this.manager, eventType, {\n        pointers: [ev],\n        changedPointers: [ev],\n        pointerType: INPUT_TYPE_MOUSE,\n        srcEvent: ev\n      });\n    }\n  });\n  var POINTER_INPUT_MAP = {\n    pointerdown: INPUT_START,\n    pointermove: INPUT_MOVE,\n    pointerup: INPUT_END,\n    pointercancel: INPUT_CANCEL,\n    pointerout: INPUT_CANCEL\n  };\n\n  // in IE10 the pointer types is defined as an enum\n  var IE10_POINTER_TYPE_ENUM = {\n    2: INPUT_TYPE_TOUCH,\n    3: INPUT_TYPE_PEN,\n    4: INPUT_TYPE_MOUSE,\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n  };\n  var POINTER_ELEMENT_EVENTS = 'pointerdown';\n  var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n  // IE10 has prefixed support, and case-sensitive\n  if (window.MSPointerEvent && !window.PointerEvent) {\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n  }\n\n  /**\n   * Pointer events input\n   * @constructor\n   * @extends Input\n   */\n  function PointerEventInput() {\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n    Input.apply(this, arguments);\n    this.store = this.manager.session.pointerEvents = [];\n  }\n  inherit(PointerEventInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function PEhandler(ev) {\n      var store = this.store;\n      var removePointer = false;\n      var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n      var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n      var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n      var isTouch = pointerType == INPUT_TYPE_TOUCH;\n\n      // get index of the event in the store\n      var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n      // start and mouse must be down\n      if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n        if (storeIndex < 0) {\n          store.push(ev);\n          storeIndex = store.length - 1;\n        }\n      } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n        removePointer = true;\n      }\n\n      // it not found, so the pointer hasn't been down (so it's probably a hover)\n      if (storeIndex < 0) {\n        return;\n      }\n\n      // update the event in the store\n      store[storeIndex] = ev;\n      this.callback(this.manager, eventType, {\n        pointers: store,\n        changedPointers: [ev],\n        pointerType: pointerType,\n        srcEvent: ev\n      });\n      if (removePointer) {\n        // remove from the store\n        store.splice(storeIndex, 1);\n      }\n    }\n  });\n  var SINGLE_TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n  };\n  var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\n  var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n  /**\n   * Touch events input\n   * @constructor\n   * @extends Input\n   */\n  function SingleTouchInput() {\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    this.started = false;\n    Input.apply(this, arguments);\n  }\n  inherit(SingleTouchInput, Input, {\n    handler: function TEhandler(ev) {\n      var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n      // should we handle the touch events?\n      if (type === INPUT_START) {\n        this.started = true;\n      }\n      if (!this.started) {\n        return;\n      }\n      var touches = normalizeSingleTouches.call(this, ev, type);\n\n      // when done, reset the started state\n      if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n        this.started = false;\n      }\n      this.callback(this.manager, type, {\n        pointers: touches[0],\n        changedPointers: touches[1],\n        pointerType: INPUT_TYPE_TOUCH,\n        srcEvent: ev\n      });\n    }\n  });\n\n  /**\n   * @this {TouchInput}\n   * @param {Object} ev\n   * @param {Number} type flag\n   * @returns {undefined|Array} [all, changed]\n   */\n  function normalizeSingleTouches(ev, type) {\n    var all = toArray(ev.touches);\n    var changed = toArray(ev.changedTouches);\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n      all = uniqueArray(all.concat(changed), 'identifier', true);\n    }\n    return [all, changed];\n  }\n  var TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n  };\n  var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n  /**\n   * Multi-user touch events input\n   * @constructor\n   * @extends Input\n   */\n  function TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n    Input.apply(this, arguments);\n  }\n  inherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n      var type = TOUCH_INPUT_MAP[ev.type];\n      var touches = getTouches.call(this, ev, type);\n      if (!touches) {\n        return;\n      }\n      this.callback(this.manager, type, {\n        pointers: touches[0],\n        changedPointers: touches[1],\n        pointerType: INPUT_TYPE_TOUCH,\n        srcEvent: ev\n      });\n    }\n  });\n\n  /**\n   * @this {TouchInput}\n   * @param {Object} ev\n   * @param {Number} type flag\n   * @returns {undefined|Array} [all, changed]\n   */\n  function getTouches(ev, type) {\n    var allTouches = toArray(ev.touches);\n    var targetIds = this.targetIds;\n\n    // when there is only one touch, the process can be simplified\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n      targetIds[allTouches[0].identifier] = true;\n      return [allTouches, allTouches];\n    }\n    var i,\n      targetTouches,\n      changedTouches = toArray(ev.changedTouches),\n      changedTargetTouches = [],\n      target = this.target;\n\n    // get target touches from touches\n    targetTouches = allTouches.filter(function (touch) {\n      return hasParent(touch.target, target);\n    });\n\n    // collect touches\n    if (type === INPUT_START) {\n      i = 0;\n      while (i < targetTouches.length) {\n        targetIds[targetTouches[i].identifier] = true;\n        i++;\n      }\n    }\n\n    // filter changed touches to only contain touches that exist in the collected target ids\n    i = 0;\n    while (i < changedTouches.length) {\n      if (targetIds[changedTouches[i].identifier]) {\n        changedTargetTouches.push(changedTouches[i]);\n      }\n\n      // cleanup removed touches\n      if (type & (INPUT_END | INPUT_CANCEL)) {\n        delete targetIds[changedTouches[i].identifier];\n      }\n      i++;\n    }\n    if (!changedTargetTouches.length) {\n      return;\n    }\n    return [\n    // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n    uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];\n  }\n\n  /**\n   * Combined touch and mouse input\n   *\n   * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n   * This because touch devices also emit mouse events while doing a touch.\n   *\n   * @constructor\n   * @extends Input\n   */\n\n  var DEDUP_TIMEOUT = 2500;\n  var DEDUP_DISTANCE = 25;\n  function TouchMouseInput() {\n    Input.apply(this, arguments);\n    var handler = bindFn(this.handler, this);\n    this.touch = new TouchInput(this.manager, handler);\n    this.mouse = new MouseInput(this.manager, handler);\n    this.primaryTouch = null;\n    this.lastTouches = [];\n  }\n  inherit(TouchMouseInput, Input, {\n    /**\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n    handler: function TMEhandler(manager, inputEvent, inputData) {\n      var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,\n        isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;\n      if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n        return;\n      }\n\n      // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n      if (isTouch) {\n        recordTouches.call(this, inputEvent, inputData);\n      } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n        return;\n      }\n      this.callback(manager, inputEvent, inputData);\n    },\n    /**\n     * remove the event listeners\n     */\n    destroy: function destroy() {\n      this.touch.destroy();\n      this.mouse.destroy();\n    }\n  });\n  function recordTouches(eventType, eventData) {\n    if (eventType & INPUT_START) {\n      this.primaryTouch = eventData.changedPointers[0].identifier;\n      setLastTouch.call(this, eventData);\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n      setLastTouch.call(this, eventData);\n    }\n  }\n  function setLastTouch(eventData) {\n    var touch = eventData.changedPointers[0];\n    if (touch.identifier === this.primaryTouch) {\n      var lastTouch = {\n        x: touch.clientX,\n        y: touch.clientY\n      };\n      this.lastTouches.push(lastTouch);\n      var lts = this.lastTouches;\n      var removeLastTouch = function () {\n        var i = lts.indexOf(lastTouch);\n        if (i > -1) {\n          lts.splice(i, 1);\n        }\n      };\n      setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n    }\n  }\n  function isSyntheticEvent(eventData) {\n    var x = eventData.srcEvent.clientX,\n      y = eventData.srcEvent.clientY;\n    for (var i = 0; i < this.lastTouches.length; i++) {\n      var t = this.lastTouches[i];\n      var dx = Math.abs(x - t.x),\n        dy = Math.abs(y - t.y);\n      if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n        return true;\n      }\n    }\n    return false;\n  }\n  var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\n  var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\n  // magical touchAction value\n  var TOUCH_ACTION_COMPUTE = 'compute';\n  var TOUCH_ACTION_AUTO = 'auto';\n  var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n  var TOUCH_ACTION_NONE = 'none';\n  var TOUCH_ACTION_PAN_X = 'pan-x';\n  var TOUCH_ACTION_PAN_Y = 'pan-y';\n  var TOUCH_ACTION_MAP = getTouchActionProps();\n\n  /**\n   * Touch Action\n   * sets the touchAction property or uses the js alternative\n   * @param {Manager} manager\n   * @param {String} value\n   * @constructor\n   */\n  function TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n  }\n  TouchAction.prototype = {\n    /**\n     * set the touchAction value on the element or enable the polyfill\n     * @param {String} value\n     */\n    set: function (value) {\n      // find out the touch-action by the event handlers\n      if (value == TOUCH_ACTION_COMPUTE) {\n        value = this.compute();\n      }\n      if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n        this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n      }\n      this.actions = value.toLowerCase().trim();\n    },\n    /**\n     * just re-set the touchAction value\n     */\n    update: function () {\n      this.set(this.manager.options.touchAction);\n    },\n    /**\n     * compute the value for the touchAction property based on the recognizer's settings\n     * @returns {String} value\n     */\n    compute: function () {\n      var actions = [];\n      each(this.manager.recognizers, function (recognizer) {\n        if (boolOrFn(recognizer.options.enable, [recognizer])) {\n          actions = actions.concat(recognizer.getTouchAction());\n        }\n      });\n      return cleanTouchActions(actions.join(' '));\n    },\n    /**\n     * this method is called on each input cycle and provides the preventing of the browser behavior\n     * @param {Object} input\n     */\n    preventDefaults: function (input) {\n      var srcEvent = input.srcEvent;\n      var direction = input.offsetDirection;\n\n      // if the touch action did prevented once this session\n      if (this.manager.session.prevented) {\n        srcEvent.preventDefault();\n        return;\n      }\n      var actions = this.actions;\n      var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n      var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n      var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n      if (hasNone) {\n        //do not prevent defaults if this is a tap gesture\n\n        var isTapPointer = input.pointers.length === 1;\n        var isTapMovement = input.distance < 2;\n        var isTapTouchTime = input.deltaTime < 250;\n        if (isTapPointer && isTapMovement && isTapTouchTime) {\n          return;\n        }\n      }\n      if (hasPanX && hasPanY) {\n        // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n        return;\n      }\n      if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {\n        return this.preventSrc(srcEvent);\n      }\n    },\n    /**\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n     * @param {Object} srcEvent\n     */\n    preventSrc: function (srcEvent) {\n      this.manager.session.prevented = true;\n      srcEvent.preventDefault();\n    }\n  };\n\n  /**\n   * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n   * @param {String} actions\n   * @returns {*}\n   */\n  function cleanTouchActions(actions) {\n    // none\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\n      return TOUCH_ACTION_NONE;\n    }\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n    // if both pan-x and pan-y are set (different recognizers\n    // for different directions, e.g. horizontal pan but vertical swipe?)\n    // we need none (as otherwise with pan-x pan-y combined none of these\n    // recognizers will work, since the browser would handle all panning\n    if (hasPanX && hasPanY) {\n      return TOUCH_ACTION_NONE;\n    }\n\n    // pan-x OR pan-y\n    if (hasPanX || hasPanY) {\n      return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n    }\n\n    // manipulation\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n      return TOUCH_ACTION_MANIPULATION;\n    }\n    return TOUCH_ACTION_AUTO;\n  }\n  function getTouchActionProps() {\n    if (!NATIVE_TOUCH_ACTION) {\n      return false;\n    }\n    var touchMap = {};\n    var cssSupports = window.CSS && window.CSS.supports;\n    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {\n      // If css.supports is not supported but there is native touch-action assume it supports\n      // all values. This is the case for IE 10 and 11.\n      touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n    });\n    return touchMap;\n  }\n\n  /**\n   * Recognizer flow explained; *\n   * All recognizers have the initial state of POSSIBLE when a input session starts.\n   * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n   * Example session for mouse-input: mousedown -> mousemove -> mouseup\n   *\n   * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n   * which determines with state it should be.\n   *\n   * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n   * POSSIBLE to give it another change on the next cycle.\n   *\n   *               Possible\n   *                  |\n   *            +-----+---------------+\n   *            |                     |\n   *      +-----+-----+               |\n   *      |           |               |\n   *   Failed      Cancelled          |\n   *                          +-------+------+\n   *                          |              |\n   *                      Recognized       Began\n   *                                         |\n   *                                      Changed\n   *                                         |\n   *                                  Ended/Recognized\n   */\n  var STATE_POSSIBLE = 1;\n  var STATE_BEGAN = 2;\n  var STATE_CHANGED = 4;\n  var STATE_ENDED = 8;\n  var STATE_RECOGNIZED = STATE_ENDED;\n  var STATE_CANCELLED = 16;\n  var STATE_FAILED = 32;\n\n  /**\n   * Recognizer\n   * Every recognizer needs to extend from this class.\n   * @constructor\n   * @param {Object} options\n   */\n  function Recognizer(options) {\n    this.options = assign({}, this.defaults, options || {});\n    this.id = uniqueId();\n    this.manager = null;\n\n    // default is enable true\n    this.options.enable = ifUndefined(this.options.enable, true);\n    this.state = STATE_POSSIBLE;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n  Recognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function (options) {\n      assign(this.options, options);\n\n      // also update the touchAction, in case something changed about the directions/enabled state\n      this.manager && this.manager.touchAction.update();\n      return this;\n    },\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function (otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n        return this;\n      }\n      var simultaneous = this.simultaneous;\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      if (!simultaneous[otherRecognizer.id]) {\n        simultaneous[otherRecognizer.id] = otherRecognizer;\n        otherRecognizer.recognizeWith(this);\n      }\n      return this;\n    },\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function (otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n        return this;\n      }\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      delete this.simultaneous[otherRecognizer.id];\n      return this;\n    },\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function (otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n        return this;\n      }\n      var requireFail = this.requireFail;\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      if (inArray(requireFail, otherRecognizer) === -1) {\n        requireFail.push(otherRecognizer);\n        otherRecognizer.requireFailure(this);\n      }\n      return this;\n    },\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function (otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n        return this;\n      }\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      var index = inArray(this.requireFail, otherRecognizer);\n      if (index > -1) {\n        this.requireFail.splice(index, 1);\n      }\n      return this;\n    },\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function () {\n      return this.requireFail.length > 0;\n    },\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function (otherRecognizer) {\n      return !!this.simultaneous[otherRecognizer.id];\n    },\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function (input) {\n      var self = this;\n      var state = this.state;\n      function emit(event) {\n        self.manager.emit(event, input);\n      }\n\n      // 'panstart' and 'panmove'\n      if (state < STATE_ENDED) {\n        emit(self.options.event + stateStr(state));\n      }\n      emit(self.options.event); // simple 'eventName' events\n\n      if (input.additionalEvent) {\n        // additional event(panleft, panright, pinchin, pinchout...)\n        emit(input.additionalEvent);\n      }\n\n      // panend and pancancel\n      if (state >= STATE_ENDED) {\n        emit(self.options.event + stateStr(state));\n      }\n    },\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function (input) {\n      if (this.canEmit()) {\n        return this.emit(input);\n      }\n      // it's failing anyway\n      this.state = STATE_FAILED;\n    },\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function () {\n      var i = 0;\n      while (i < this.requireFail.length) {\n        if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n          return false;\n        }\n        i++;\n      }\n      return true;\n    },\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function (inputData) {\n      // make a new copy of the inputData\n      // so we can change the inputData without messing up the other recognizers\n      var inputDataClone = assign({}, inputData);\n\n      // is is enabled and allow recognizing?\n      if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n        this.reset();\n        this.state = STATE_FAILED;\n        return;\n      }\n\n      // reset when we've reached the end\n      if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n        this.state = STATE_POSSIBLE;\n      }\n      this.state = this.process(inputDataClone);\n\n      // the recognizer has recognized a gesture\n      // so trigger an event\n      if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n        this.tryEmit(inputDataClone);\n      }\n    },\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function (inputData) {},\n    // jshint ignore:line\n\n    /**\n     * return the preferred touch-action\n     * @virtual\n     * @returns {Array}\n     */\n    getTouchAction: function () {},\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function () {}\n  };\n\n  /**\n   * get a usable string, used as event postfix\n   * @param {Const} state\n   * @returns {String} state\n   */\n  function stateStr(state) {\n    if (state & STATE_CANCELLED) {\n      return 'cancel';\n    } else if (state & STATE_ENDED) {\n      return 'end';\n    } else if (state & STATE_CHANGED) {\n      return 'move';\n    } else if (state & STATE_BEGAN) {\n      return 'start';\n    }\n    return '';\n  }\n\n  /**\n   * direction cons to string\n   * @param {Const} direction\n   * @returns {String}\n   */\n  function directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n      return 'down';\n    } else if (direction == DIRECTION_UP) {\n      return 'up';\n    } else if (direction == DIRECTION_LEFT) {\n      return 'left';\n    } else if (direction == DIRECTION_RIGHT) {\n      return 'right';\n    }\n    return '';\n  }\n\n  /**\n   * get a recognizer by name if it is bound to a manager\n   * @param {Recognizer|String} otherRecognizer\n   * @param {Recognizer} recognizer\n   * @returns {Recognizer}\n   */\n  function getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n    if (manager) {\n      return manager.get(otherRecognizer);\n    }\n    return otherRecognizer;\n  }\n\n  /**\n   * This recognizer is just used as a base for the simple attribute recognizers.\n   * @constructor\n   * @extends Recognizer\n   */\n  function AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n  }\n  inherit(AttrRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof AttrRecognizer\n     */\n    defaults: {\n      /**\n       * @type {Number}\n       * @default 1\n       */\n      pointers: 1\n    },\n    /**\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {Boolean} recognized\n     */\n    attrTest: function (input) {\n      var optionPointers = this.options.pointers;\n      return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n    /**\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n    process: function (input) {\n      var state = this.state;\n      var eventType = input.eventType;\n      var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n      var isValid = this.attrTest(input);\n\n      // on cancel input and we've recognized before, return STATE_CANCELLED\n      if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n        return state | STATE_CANCELLED;\n      } else if (isRecognized || isValid) {\n        if (eventType & INPUT_END) {\n          return state | STATE_ENDED;\n        } else if (!(state & STATE_BEGAN)) {\n          return STATE_BEGAN;\n        }\n        return state | STATE_CHANGED;\n      }\n      return STATE_FAILED;\n    }\n  });\n\n  /**\n   * Pan\n   * Recognized when the pointer is down and moved in the allowed direction.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n  function PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n    this.pX = null;\n    this.pY = null;\n  }\n  inherit(PanRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PanRecognizer\n     */\n    defaults: {\n      event: 'pan',\n      threshold: 10,\n      pointers: 1,\n      direction: DIRECTION_ALL\n    },\n    getTouchAction: function () {\n      var direction = this.options.direction;\n      var actions = [];\n      if (direction & DIRECTION_HORIZONTAL) {\n        actions.push(TOUCH_ACTION_PAN_Y);\n      }\n      if (direction & DIRECTION_VERTICAL) {\n        actions.push(TOUCH_ACTION_PAN_X);\n      }\n      return actions;\n    },\n    directionTest: function (input) {\n      var options = this.options;\n      var hasMoved = true;\n      var distance = input.distance;\n      var direction = input.direction;\n      var x = input.deltaX;\n      var y = input.deltaY;\n\n      // lock to axis?\n      if (!(direction & options.direction)) {\n        if (options.direction & DIRECTION_HORIZONTAL) {\n          direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n          hasMoved = x != this.pX;\n          distance = Math.abs(input.deltaX);\n        } else {\n          direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n          hasMoved = y != this.pY;\n          distance = Math.abs(input.deltaY);\n        }\n      }\n      input.direction = direction;\n      return hasMoved && distance > options.threshold && direction & options.direction;\n    },\n    attrTest: function (input) {\n      return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));\n    },\n    emit: function (input) {\n      this.pX = input.deltaX;\n      this.pY = input.deltaY;\n      var direction = directionStr(input.direction);\n      if (direction) {\n        input.additionalEvent = this.options.event + direction;\n      }\n      this._super.emit.call(this, input);\n    }\n  });\n\n  /**\n   * Pinch\n   * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n   * @constructor\n   * @extends AttrRecognizer\n   */\n  function PinchRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n  inherit(PinchRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n      event: 'pinch',\n      threshold: 0,\n      pointers: 2\n    },\n    getTouchAction: function () {\n      return [TOUCH_ACTION_NONE];\n    },\n    attrTest: function (input) {\n      return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n    },\n    emit: function (input) {\n      if (input.scale !== 1) {\n        var inOut = input.scale < 1 ? 'in' : 'out';\n        input.additionalEvent = this.options.event + inOut;\n      }\n      this._super.emit.call(this, input);\n    }\n  });\n\n  /**\n   * Press\n   * Recognized when the pointer is down for x ms without any movement.\n   * @constructor\n   * @extends Recognizer\n   */\n  function PressRecognizer() {\n    Recognizer.apply(this, arguments);\n    this._timer = null;\n    this._input = null;\n  }\n  inherit(PressRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PressRecognizer\n     */\n    defaults: {\n      event: 'press',\n      pointers: 1,\n      time: 251,\n      // minimal time of the pointer to be pressed\n      threshold: 9 // a minimal movement is ok, but keep it low\n    },\n    getTouchAction: function () {\n      return [TOUCH_ACTION_AUTO];\n    },\n    process: function (input) {\n      var options = this.options;\n      var validPointers = input.pointers.length === options.pointers;\n      var validMovement = input.distance < options.threshold;\n      var validTime = input.deltaTime > options.time;\n      this._input = input;\n\n      // we only allow little movement\n      // and we've reached an end event, so a tap is possible\n      if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {\n        this.reset();\n      } else if (input.eventType & INPUT_START) {\n        this.reset();\n        this._timer = setTimeoutContext(function () {\n          this.state = STATE_RECOGNIZED;\n          this.tryEmit();\n        }, options.time, this);\n      } else if (input.eventType & INPUT_END) {\n        return STATE_RECOGNIZED;\n      }\n      return STATE_FAILED;\n    },\n    reset: function () {\n      clearTimeout(this._timer);\n    },\n    emit: function (input) {\n      if (this.state !== STATE_RECOGNIZED) {\n        return;\n      }\n      if (input && input.eventType & INPUT_END) {\n        this.manager.emit(this.options.event + 'up', input);\n      } else {\n        this._input.timeStamp = now();\n        this.manager.emit(this.options.event, this._input);\n      }\n    }\n  });\n\n  /**\n   * Rotate\n   * Recognized when two or more pointer are moving in a circular motion.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n  function RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n  inherit(RotateRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof RotateRecognizer\n     */\n    defaults: {\n      event: 'rotate',\n      threshold: 0,\n      pointers: 2\n    },\n    getTouchAction: function () {\n      return [TOUCH_ACTION_NONE];\n    },\n    attrTest: function (input) {\n      return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n    }\n  });\n\n  /**\n   * Swipe\n   * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n  function SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n  inherit(SwipeRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof SwipeRecognizer\n     */\n    defaults: {\n      event: 'swipe',\n      threshold: 10,\n      velocity: 0.3,\n      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n      pointers: 1\n    },\n    getTouchAction: function () {\n      return PanRecognizer.prototype.getTouchAction.call(this);\n    },\n    attrTest: function (input) {\n      var direction = this.options.direction;\n      var velocity;\n      if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n        velocity = input.overallVelocity;\n      } else if (direction & DIRECTION_HORIZONTAL) {\n        velocity = input.overallVelocityX;\n      } else if (direction & DIRECTION_VERTICAL) {\n        velocity = input.overallVelocityY;\n      }\n      return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n    },\n    emit: function (input) {\n      var direction = directionStr(input.offsetDirection);\n      if (direction) {\n        this.manager.emit(this.options.event + direction, input);\n      }\n      this.manager.emit(this.options.event, input);\n    }\n  });\n\n  /**\n   * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n   * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n   * a single tap.\n   *\n   * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n   * multi-taps being recognized.\n   * @constructor\n   * @extends Recognizer\n   */\n  function TapRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n  }\n  inherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n      event: 'tap',\n      pointers: 1,\n      taps: 1,\n      interval: 300,\n      // max time between the multi-tap taps\n      time: 250,\n      // max time of the pointer to be down (like finger on the screen)\n      threshold: 9,\n      // a minimal movement is ok, but keep it low\n      posThreshold: 10 // a multi-tap can be a bit off the initial position\n    },\n    getTouchAction: function () {\n      return [TOUCH_ACTION_MANIPULATION];\n    },\n    process: function (input) {\n      var options = this.options;\n      var validPointers = input.pointers.length === options.pointers;\n      var validMovement = input.distance < options.threshold;\n      var validTouchTime = input.deltaTime < options.time;\n      this.reset();\n      if (input.eventType & INPUT_START && this.count === 0) {\n        return this.failTimeout();\n      }\n\n      // we only allow little movement\n      // and we've reached an end event, so a tap is possible\n      if (validMovement && validTouchTime && validPointers) {\n        if (input.eventType != INPUT_END) {\n          return this.failTimeout();\n        }\n        var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n        var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n        this.pTime = input.timeStamp;\n        this.pCenter = input.center;\n        if (!validMultiTap || !validInterval) {\n          this.count = 1;\n        } else {\n          this.count += 1;\n        }\n        this._input = input;\n\n        // if tap count matches we have recognized it,\n        // else it has began recognizing...\n        var tapCount = this.count % options.taps;\n        if (tapCount === 0) {\n          // no failing requirements, immediately trigger the tap event\n          // or wait as long as the multitap interval to trigger\n          if (!this.hasRequireFailures()) {\n            return STATE_RECOGNIZED;\n          } else {\n            this._timer = setTimeoutContext(function () {\n              this.state = STATE_RECOGNIZED;\n              this.tryEmit();\n            }, options.interval, this);\n            return STATE_BEGAN;\n          }\n        }\n      }\n      return STATE_FAILED;\n    },\n    failTimeout: function () {\n      this._timer = setTimeoutContext(function () {\n        this.state = STATE_FAILED;\n      }, this.options.interval, this);\n      return STATE_FAILED;\n    },\n    reset: function () {\n      clearTimeout(this._timer);\n    },\n    emit: function () {\n      if (this.state == STATE_RECOGNIZED) {\n        this._input.tapCount = this.count;\n        this.manager.emit(this.options.event, this._input);\n      }\n    }\n  });\n\n  /**\n   * Simple way to create a manager with a default set of recognizers.\n   * @param {HTMLElement} element\n   * @param {Object} [options]\n   * @constructor\n   */\n  function Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n    return new Manager(element, options);\n  }\n\n  /**\n   * @const {string}\n   */\n  Hammer.VERSION = '2.0.7';\n\n  /**\n   * default settings\n   * @namespace\n   */\n  Hammer.defaults = {\n    /**\n     * set if DOM events are being triggered.\n     * But this is slower and unused by simple implementations, so disabled by default.\n     * @type {Boolean}\n     * @default false\n     */\n    domEvents: false,\n    /**\n     * The value for the touchAction property/fallback.\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\n     * @type {String}\n     * @default compute\n     */\n    touchAction: TOUCH_ACTION_COMPUTE,\n    /**\n     * @type {Boolean}\n     * @default true\n     */\n    enable: true,\n    /**\n     * EXPERIMENTAL FEATURE -- can be removed/changed\n     * Change the parent input target element.\n     * If Null, then it is being set the to main element.\n     * @type {Null|EventTarget}\n     * @default null\n     */\n    inputTarget: null,\n    /**\n     * force an input class\n     * @type {Null|Function}\n     * @default null\n     */\n    inputClass: null,\n    /**\n     * Default recognizer setup when calling `Hammer()`\n     * When creating a new Manager these will be skipped.\n     * @type {Array}\n     */\n    preset: [\n    // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n    [RotateRecognizer, {\n      enable: false\n    }], [PinchRecognizer, {\n      enable: false\n    }, ['rotate']], [SwipeRecognizer, {\n      direction: DIRECTION_HORIZONTAL\n    }], [PanRecognizer, {\n      direction: DIRECTION_HORIZONTAL\n    }, ['swipe']], [TapRecognizer], [TapRecognizer, {\n      event: 'doubletap',\n      taps: 2\n    }, ['tap']], [PressRecognizer]],\n    /**\n     * Some CSS properties can be used to improve the working of Hammer.\n     * Add them to this method and they will be set when creating a new Manager.\n     * @namespace\n     */\n    cssProps: {\n      /**\n       * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n       * @type {String}\n       * @default 'none'\n       */\n      userSelect: 'none',\n      /**\n       * Disable the Windows Phone grippers when pressing an element.\n       * @type {String}\n       * @default 'none'\n       */\n      touchSelect: 'none',\n      /**\n       * Disables the default callout shown when you touch and hold a touch target.\n       * On iOS, when you touch and hold a touch target such as a link, Safari displays\n       * a callout containing information about the link. This property allows you to disable that callout.\n       * @type {String}\n       * @default 'none'\n       */\n      touchCallout: 'none',\n      /**\n       * Specifies whether zooming is enabled. Used by IE10>\n       * @type {String}\n       * @default 'none'\n       */\n      contentZooming: 'none',\n      /**\n       * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n       * @type {String}\n       * @default 'none'\n       */\n      userDrag: 'none',\n      /**\n       * Overrides the highlight color shown when the user taps a link or a JavaScript\n       * clickable element in iOS. This property obeys the alpha value, if specified.\n       * @type {String}\n       * @default 'rgba(0,0,0,0)'\n       */\n      tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n  };\n  var STOP = 1;\n  var FORCED_STOP = 2;\n\n  /**\n   * Manager\n   * @param {HTMLElement} element\n   * @param {Object} [options]\n   * @constructor\n   */\n  function Manager(element, options) {\n    this.options = assign({}, Hammer.defaults, options || {});\n    this.options.inputTarget = this.options.inputTarget || element;\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n    toggleCssProps(this, true);\n    each(this.options.recognizers, function (item) {\n      var recognizer = this.add(new item[0](item[1]));\n      item[2] && recognizer.recognizeWith(item[2]);\n      item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n  }\n  Manager.prototype = {\n    /**\n     * set options\n     * @param {Object} options\n     * @returns {Manager}\n     */\n    set: function (options) {\n      assign(this.options, options);\n\n      // Options that need a little more setup\n      if (options.touchAction) {\n        this.touchAction.update();\n      }\n      if (options.inputTarget) {\n        // Clean up existing event listeners and reinitialize\n        this.input.destroy();\n        this.input.target = options.inputTarget;\n        this.input.init();\n      }\n      return this;\n    },\n    /**\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n    stop: function (force) {\n      this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n    /**\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n    recognize: function (inputData) {\n      var session = this.session;\n      if (session.stopped) {\n        return;\n      }\n\n      // run the touch-action polyfill\n      this.touchAction.preventDefaults(inputData);\n      var recognizer;\n      var recognizers = this.recognizers;\n\n      // this holds the recognizer that is being recognized.\n      // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n      // if no recognizer is detecting a thing, it is set to `null`\n      var curRecognizer = session.curRecognizer;\n\n      // reset when the last recognizer is recognized\n      // or when we're in a new session\n      if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {\n        curRecognizer = session.curRecognizer = null;\n      }\n      var i = 0;\n      while (i < recognizers.length) {\n        recognizer = recognizers[i];\n\n        // find out if we are allowed try to recognize the input for this one.\n        // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n        // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n        //      that is being recognized.\n        // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n        //      this can be setup with the `recognizeWith()` method on the recognizer.\n        if (session.stopped !== FORCED_STOP && (\n        // 1\n        !curRecognizer || recognizer == curRecognizer ||\n        // 2\n        recognizer.canRecognizeWith(curRecognizer))) {\n          // 3\n          recognizer.recognize(inputData);\n        } else {\n          recognizer.reset();\n        }\n\n        // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n        // current active recognizer. but only if we don't already have an active recognizer\n        if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n          curRecognizer = session.curRecognizer = recognizer;\n        }\n        i++;\n      }\n    },\n    /**\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n    get: function (recognizer) {\n      if (recognizer instanceof Recognizer) {\n        return recognizer;\n      }\n      var recognizers = this.recognizers;\n      for (var i = 0; i < recognizers.length; i++) {\n        if (recognizers[i].options.event == recognizer) {\n          return recognizers[i];\n        }\n      }\n      return null;\n    },\n    /**\n     * add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n    add: function (recognizer) {\n      if (invokeArrayArg(recognizer, 'add', this)) {\n        return this;\n      }\n\n      // remove existing\n      var existing = this.get(recognizer.options.event);\n      if (existing) {\n        this.remove(existing);\n      }\n      this.recognizers.push(recognizer);\n      recognizer.manager = this;\n      this.touchAction.update();\n      return recognizer;\n    },\n    /**\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n    remove: function (recognizer) {\n      if (invokeArrayArg(recognizer, 'remove', this)) {\n        return this;\n      }\n      recognizer = this.get(recognizer);\n\n      // let's make sure this recognizer exists\n      if (recognizer) {\n        var recognizers = this.recognizers;\n        var index = inArray(recognizers, recognizer);\n        if (index !== -1) {\n          recognizers.splice(index, 1);\n          this.touchAction.update();\n        }\n      }\n      return this;\n    },\n    /**\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @returns {EventEmitter} this\n     */\n    on: function (events, handler) {\n      if (events === undefined) {\n        return;\n      }\n      if (handler === undefined) {\n        return;\n      }\n      var handlers = this.handlers;\n      each(splitStr(events), function (event) {\n        handlers[event] = handlers[event] || [];\n        handlers[event].push(handler);\n      });\n      return this;\n    },\n    /**\n     * unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n    off: function (events, handler) {\n      if (events === undefined) {\n        return;\n      }\n      var handlers = this.handlers;\n      each(splitStr(events), function (event) {\n        if (!handler) {\n          delete handlers[event];\n        } else {\n          handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n        }\n      });\n      return this;\n    },\n    /**\n     * emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n    emit: function (event, data) {\n      // we also want to trigger dom events\n      if (this.options.domEvents) {\n        triggerDomEvent(event, data);\n      }\n\n      // no handlers, so skip it all\n      var handlers = this.handlers[event] && this.handlers[event].slice();\n      if (!handlers || !handlers.length) {\n        return;\n      }\n      data.type = event;\n      data.preventDefault = function () {\n        data.srcEvent.preventDefault();\n      };\n      var i = 0;\n      while (i < handlers.length) {\n        handlers[i](data);\n        i++;\n      }\n    },\n    /**\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n    destroy: function () {\n      this.element && toggleCssProps(this, false);\n      this.handlers = {};\n      this.session = {};\n      this.input.destroy();\n      this.element = null;\n    }\n  };\n\n  /**\n   * add/remove the css properties as defined in manager.options.cssProps\n   * @param {Manager} manager\n   * @param {Boolean} add\n   */\n  function toggleCssProps(manager, add) {\n    var element = manager.element;\n    if (!element.style) {\n      return;\n    }\n    var prop;\n    each(manager.options.cssProps, function (value, name) {\n      prop = prefixed(element.style, name);\n      if (add) {\n        manager.oldCssProps[prop] = element.style[prop];\n        element.style[prop] = value;\n      } else {\n        element.style[prop] = manager.oldCssProps[prop] || '';\n      }\n    });\n    if (!add) {\n      manager.oldCssProps = {};\n    }\n  }\n\n  /**\n   * trigger dom event\n   * @param {String} event\n   * @param {Object} data\n   */\n  function triggerDomEvent(event, data) {\n    var gestureEvent = document.createEvent('Event');\n    gestureEvent.initEvent(event, true, true);\n    gestureEvent.gesture = data;\n    data.target.dispatchEvent(gestureEvent);\n  }\n  assign(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n    Manager: Manager,\n    Input: Input,\n    TouchAction: TouchAction,\n    TouchInput: TouchInput,\n    MouseInput: MouseInput,\n    PointerEventInput: PointerEventInput,\n    TouchMouseInput: TouchMouseInput,\n    SingleTouchInput: SingleTouchInput,\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Pinch: PinchRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    assign: assign,\n    inherit: inherit,\n    bindFn: bindFn,\n    prefixed: prefixed\n  });\n\n  // this prevents errors when Hammer is loaded in the presence of an AMD\n  //  style loader but by script tag, not by the loader.\n  var freeGlobal = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}; // jshint ignore:line\n  freeGlobal.Hammer = Hammer;\n  if (typeof define === 'function' && define.amd) {\n    define(function () {\n      return Hammer;\n    });\n  } else if (typeof module != 'undefined' && module.exports) {\n    module.exports = Hammer;\n  } else {\n    window[exportName] = Hammer;\n  }\n})(window, document, 'Hammer');", "/*!\n* chartjs-plugin-zoom v2.2.0\n* https://www.chartjs.org/chartjs-plugin-zoom/2.2.0/\n * (c) 2016-2024 chartjs-plugin-zoom Contributors\n * Released under the MIT License\n */\nimport Hammer from 'hammerjs';\nimport { each, valueOrDefault, almostEquals, callback, sign, getRelativePosition, _isPointInArea } from 'chart.js/helpers';\nconst getModifierKey = opts => opts && opts.enabled && opts.modifierKey;\nconst keyPressed = (key, event) => key && event[key + 'Key'];\nconst keyNotPressed = (key, event) => key && !event[key + 'Key'];\nfunction directionEnabled(mode, dir, chart) {\n  if (mode === undefined) {\n    return true;\n  } else if (typeof mode === 'string') {\n    return mode.indexOf(dir) !== -1;\n  } else if (typeof mode === 'function') {\n    return mode({\n      chart\n    }).indexOf(dir) !== -1;\n  }\n  return false;\n}\nfunction directionsEnabled(mode, chart) {\n  if (typeof mode === 'function') {\n    mode = mode({\n      chart\n    });\n  }\n  if (typeof mode === 'string') {\n    return {\n      x: mode.indexOf('x') !== -1,\n      y: mode.indexOf('y') !== -1\n    };\n  }\n  return {\n    x: false,\n    y: false\n  };\n}\nfunction debounce(fn, delay) {\n  let timeout;\n  return function () {\n    clearTimeout(timeout);\n    timeout = setTimeout(fn, delay);\n    return delay;\n  };\n}\nfunction getScaleUnderPoint({\n  x,\n  y\n}, chart) {\n  const scales = chart.scales;\n  const scaleIds = Object.keys(scales);\n  for (let i = 0; i < scaleIds.length; i++) {\n    const scale = scales[scaleIds[i]];\n    if (y >= scale.top && y <= scale.bottom && x >= scale.left && x <= scale.right) {\n      return scale;\n    }\n  }\n  return null;\n}\nfunction getEnabledScalesByPoint(options, point, chart) {\n  const {\n    mode = 'xy',\n    scaleMode,\n    overScaleMode\n  } = options || {};\n  const scale = getScaleUnderPoint(point, chart);\n  const enabled = directionsEnabled(mode, chart);\n  const scaleEnabled = directionsEnabled(scaleMode, chart);\n  if (overScaleMode) {\n    const overScaleEnabled = directionsEnabled(overScaleMode, chart);\n    for (const axis of ['x', 'y']) {\n      if (overScaleEnabled[axis]) {\n        scaleEnabled[axis] = enabled[axis];\n        enabled[axis] = false;\n      }\n    }\n  }\n  if (scale && scaleEnabled[scale.axis]) {\n    return [scale];\n  }\n  const enabledScales = [];\n  each(chart.scales, function (scaleItem) {\n    if (enabled[scaleItem.axis]) {\n      enabledScales.push(scaleItem);\n    }\n  });\n  return enabledScales;\n}\nconst chartStates = new WeakMap();\nfunction getState(chart) {\n  let state = chartStates.get(chart);\n  if (!state) {\n    state = {\n      originalScaleLimits: {},\n      updatedScaleLimits: {},\n      handlers: {},\n      panDelta: {},\n      dragging: false,\n      panning: false\n    };\n    chartStates.set(chart, state);\n  }\n  return state;\n}\nfunction removeState(chart) {\n  chartStates.delete(chart);\n}\nfunction zoomDelta(val, min, range, newRange) {\n  const minPercent = Math.max(0, Math.min(1, (val - min) / range || 0));\n  const maxPercent = 1 - minPercent;\n  return {\n    min: newRange * minPercent,\n    max: newRange * maxPercent\n  };\n}\nfunction getValueAtPoint(scale, point) {\n  const pixel = scale.isHorizontal() ? point.x : point.y;\n  return scale.getValueForPixel(pixel);\n}\nfunction linearZoomDelta(scale, zoom, center) {\n  const range = scale.max - scale.min;\n  const newRange = range * (zoom - 1);\n  const centerValue = getValueAtPoint(scale, center);\n  return zoomDelta(centerValue, scale.min, range, newRange);\n}\nfunction logarithmicZoomRange(scale, zoom, center) {\n  const centerValue = getValueAtPoint(scale, center);\n  if (centerValue === undefined) {\n    return {\n      min: scale.min,\n      max: scale.max\n    };\n  }\n  const logMin = Math.log10(scale.min);\n  const logMax = Math.log10(scale.max);\n  const logCenter = Math.log10(centerValue);\n  const logRange = logMax - logMin;\n  const newLogRange = logRange * (zoom - 1);\n  const delta = zoomDelta(logCenter, logMin, logRange, newLogRange);\n  return {\n    min: Math.pow(10, logMin + delta.min),\n    max: Math.pow(10, logMax - delta.max)\n  };\n}\nfunction getScaleLimits(scale, limits) {\n  return limits && (limits[scale.id] || limits[scale.axis]) || {};\n}\nfunction getLimit(state, scale, scaleLimits, prop, fallback) {\n  let limit = scaleLimits[prop];\n  if (limit === 'original') {\n    const original = state.originalScaleLimits[scale.id][prop];\n    limit = valueOrDefault(original.options, original.scale);\n  }\n  return valueOrDefault(limit, fallback);\n}\nfunction linearRange(scale, pixel0, pixel1) {\n  const v0 = scale.getValueForPixel(pixel0);\n  const v1 = scale.getValueForPixel(pixel1);\n  return {\n    min: Math.min(v0, v1),\n    max: Math.max(v0, v1)\n  };\n}\nfunction fixRange(range, {\n  min,\n  max,\n  minLimit,\n  maxLimit\n}, originalLimits) {\n  const offset = (range - max + min) / 2;\n  min -= offset;\n  max += offset;\n  const origMin = originalLimits.min.options ?? originalLimits.min.scale;\n  const origMax = originalLimits.max.options ?? originalLimits.max.scale;\n  const epsilon = range / 1e6;\n  if (almostEquals(min, origMin, epsilon)) {\n    min = origMin;\n  }\n  if (almostEquals(max, origMax, epsilon)) {\n    max = origMax;\n  }\n  if (min < minLimit) {\n    min = minLimit;\n    max = Math.min(minLimit + range, maxLimit);\n  } else if (max > maxLimit) {\n    max = maxLimit;\n    min = Math.max(maxLimit - range, minLimit);\n  }\n  return {\n    min,\n    max\n  };\n}\nfunction updateRange(scale, {\n  min,\n  max\n}, limits, zoom = false) {\n  const state = getState(scale.chart);\n  const {\n    options: scaleOpts\n  } = scale;\n  const scaleLimits = getScaleLimits(scale, limits);\n  const {\n    minRange = 0\n  } = scaleLimits;\n  const minLimit = getLimit(state, scale, scaleLimits, 'min', -Infinity);\n  const maxLimit = getLimit(state, scale, scaleLimits, 'max', Infinity);\n  if (zoom === 'pan' && (min < minLimit || max > maxLimit)) {\n    return true;\n  }\n  const scaleRange = scale.max - scale.min;\n  const range = zoom ? Math.max(max - min, minRange) : scaleRange;\n  if (zoom && range === minRange && scaleRange <= minRange) {\n    return true;\n  }\n  const newRange = fixRange(range, {\n    min,\n    max,\n    minLimit,\n    maxLimit\n  }, state.originalScaleLimits[scale.id]);\n  scaleOpts.min = newRange.min;\n  scaleOpts.max = newRange.max;\n  state.updatedScaleLimits[scale.id] = newRange;\n  return scale.parse(newRange.min) !== scale.min || scale.parse(newRange.max) !== scale.max;\n}\nfunction zoomNumericalScale(scale, zoom, center, limits) {\n  const delta = linearZoomDelta(scale, zoom, center);\n  const newRange = {\n    min: scale.min + delta.min,\n    max: scale.max - delta.max\n  };\n  return updateRange(scale, newRange, limits, true);\n}\nfunction zoomLogarithmicScale(scale, zoom, center, limits) {\n  const newRange = logarithmicZoomRange(scale, zoom, center);\n  return updateRange(scale, newRange, limits, true);\n}\nfunction zoomRectNumericalScale(scale, from, to, limits) {\n  updateRange(scale, linearRange(scale, from, to), limits, true);\n}\nconst integerChange = v => v === 0 || isNaN(v) ? 0 : v < 0 ? Math.min(Math.round(v), -1) : Math.max(Math.round(v), 1);\nfunction existCategoryFromMaxZoom(scale) {\n  const labels = scale.getLabels();\n  const maxIndex = labels.length - 1;\n  if (scale.min > 0) {\n    scale.min -= 1;\n  }\n  if (scale.max < maxIndex) {\n    scale.max += 1;\n  }\n}\nfunction zoomCategoryScale(scale, zoom, center, limits) {\n  const delta = linearZoomDelta(scale, zoom, center);\n  if (scale.min === scale.max && zoom < 1) {\n    existCategoryFromMaxZoom(scale);\n  }\n  const newRange = {\n    min: scale.min + integerChange(delta.min),\n    max: scale.max - integerChange(delta.max)\n  };\n  return updateRange(scale, newRange, limits, true);\n}\nfunction scaleLength(scale) {\n  return scale.isHorizontal() ? scale.width : scale.height;\n}\nfunction panCategoryScale(scale, delta, limits) {\n  const labels = scale.getLabels();\n  const lastLabelIndex = labels.length - 1;\n  let {\n    min,\n    max\n  } = scale;\n  const range = Math.max(max - min, 1);\n  const stepDelta = Math.round(scaleLength(scale) / Math.max(range, 10));\n  const stepSize = Math.round(Math.abs(delta / stepDelta));\n  let applied;\n  if (delta < -stepDelta) {\n    max = Math.min(max + stepSize, lastLabelIndex);\n    min = range === 1 ? max : max - range;\n    applied = max === lastLabelIndex;\n  } else if (delta > stepDelta) {\n    min = Math.max(0, min - stepSize);\n    max = range === 1 ? min : min + range;\n    applied = min === 0;\n  }\n  return updateRange(scale, {\n    min,\n    max\n  }, limits) || applied;\n}\nconst OFFSETS = {\n  second: 500,\n  minute: 30 * 1000,\n  hour: 30 * 60 * 1000,\n  day: 12 * 60 * 60 * 1000,\n  week: 3.5 * 24 * 60 * 60 * 1000,\n  month: 15 * 24 * 60 * 60 * 1000,\n  quarter: 60 * 24 * 60 * 60 * 1000,\n  year: 182 * 24 * 60 * 60 * 1000\n};\nfunction panNumericalScale(scale, delta, limits, pan = false) {\n  const {\n    min: prevStart,\n    max: prevEnd,\n    options\n  } = scale;\n  const round = options.time && options.time.round;\n  const offset = OFFSETS[round] || 0;\n  const newMin = scale.getValueForPixel(scale.getPixelForValue(prevStart + offset) - delta);\n  const newMax = scale.getValueForPixel(scale.getPixelForValue(prevEnd + offset) - delta);\n  if (isNaN(newMin) || isNaN(newMax)) {\n    return true;\n  }\n  return updateRange(scale, {\n    min: newMin,\n    max: newMax\n  }, limits, pan ? 'pan' : false);\n}\nfunction panNonLinearScale(scale, delta, limits) {\n  return panNumericalScale(scale, delta, limits, true);\n}\nconst zoomFunctions = {\n  category: zoomCategoryScale,\n  default: zoomNumericalScale,\n  logarithmic: zoomLogarithmicScale\n};\nconst zoomRectFunctions = {\n  default: zoomRectNumericalScale\n};\nconst panFunctions = {\n  category: panCategoryScale,\n  default: panNumericalScale,\n  logarithmic: panNonLinearScale,\n  timeseries: panNonLinearScale\n};\nfunction shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits) {\n  const {\n    id,\n    options: {\n      min,\n      max\n    }\n  } = scale;\n  if (!originalScaleLimits[id] || !updatedScaleLimits[id]) {\n    return true;\n  }\n  const previous = updatedScaleLimits[id];\n  return previous.min !== min || previous.max !== max;\n}\nfunction removeMissingScales(limits, scales) {\n  each(limits, (opt, key) => {\n    if (!scales[key]) {\n      delete limits[key];\n    }\n  });\n}\nfunction storeOriginalScaleLimits(chart, state) {\n  const {\n    scales\n  } = chart;\n  const {\n    originalScaleLimits,\n    updatedScaleLimits\n  } = state;\n  each(scales, function (scale) {\n    if (shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits)) {\n      originalScaleLimits[scale.id] = {\n        min: {\n          scale: scale.min,\n          options: scale.options.min\n        },\n        max: {\n          scale: scale.max,\n          options: scale.options.max\n        }\n      };\n    }\n  });\n  removeMissingScales(originalScaleLimits, scales);\n  removeMissingScales(updatedScaleLimits, scales);\n  return originalScaleLimits;\n}\nfunction doZoom(scale, amount, center, limits) {\n  const fn = zoomFunctions[scale.type] || zoomFunctions.default;\n  callback(fn, [scale, amount, center, limits]);\n}\nfunction doZoomRect(scale, from, to, limits) {\n  const fn = zoomRectFunctions[scale.type] || zoomRectFunctions.default;\n  callback(fn, [scale, from, to, limits]);\n}\nfunction getCenter(chart) {\n  const ca = chart.chartArea;\n  return {\n    x: (ca.left + ca.right) / 2,\n    y: (ca.top + ca.bottom) / 2\n  };\n}\nfunction zoom(chart, amount, transition = 'none', trigger = 'api') {\n  const {\n    x = 1,\n    y = 1,\n    focalPoint = getCenter(chart)\n  } = typeof amount === 'number' ? {\n    x: amount,\n    y: amount\n  } : amount;\n  const state = getState(chart);\n  const {\n    options: {\n      limits,\n      zoom: zoomOptions\n    }\n  } = state;\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = x !== 1;\n  const yEnabled = y !== 1;\n  const enabledScales = getEnabledScalesByPoint(zoomOptions, focalPoint, chart);\n  each(enabledScales || chart.scales, function (scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoom(scale, x, focalPoint, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoom(scale, y, focalPoint, limits);\n    }\n  });\n  chart.update(transition);\n  callback(zoomOptions.onZoom, [{\n    chart,\n    trigger\n  }]);\n}\nfunction zoomRect(chart, p0, p1, transition = 'none', trigger = 'api') {\n  const state = getState(chart);\n  const {\n    options: {\n      limits,\n      zoom: zoomOptions\n    }\n  } = state;\n  const {\n    mode = 'xy'\n  } = zoomOptions;\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = directionEnabled(mode, 'x', chart);\n  const yEnabled = directionEnabled(mode, 'y', chart);\n  each(chart.scales, function (scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoomRect(scale, p0.x, p1.x, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoomRect(scale, p0.y, p1.y, limits);\n    }\n  });\n  chart.update(transition);\n  callback(zoomOptions.onZoom, [{\n    chart,\n    trigger\n  }]);\n}\nfunction zoomScale(chart, scaleId, range, transition = 'none', trigger = 'api') {\n  const state = getState(chart);\n  storeOriginalScaleLimits(chart, state);\n  const scale = chart.scales[scaleId];\n  updateRange(scale, range, undefined, true);\n  chart.update(transition);\n  callback(state.options.zoom?.onZoom, [{\n    chart,\n    trigger\n  }]);\n}\nfunction resetZoom(chart, transition = 'default') {\n  const state = getState(chart);\n  const originalScaleLimits = storeOriginalScaleLimits(chart, state);\n  each(chart.scales, function (scale) {\n    const scaleOptions = scale.options;\n    if (originalScaleLimits[scale.id]) {\n      scaleOptions.min = originalScaleLimits[scale.id].min.options;\n      scaleOptions.max = originalScaleLimits[scale.id].max.options;\n    } else {\n      delete scaleOptions.min;\n      delete scaleOptions.max;\n    }\n    delete state.updatedScaleLimits[scale.id];\n  });\n  chart.update(transition);\n  callback(state.options.zoom.onZoomComplete, [{\n    chart\n  }]);\n}\nfunction getOriginalRange(state, scaleId) {\n  const original = state.originalScaleLimits[scaleId];\n  if (!original) {\n    return;\n  }\n  const {\n    min,\n    max\n  } = original;\n  return valueOrDefault(max.options, max.scale) - valueOrDefault(min.options, min.scale);\n}\nfunction getZoomLevel(chart) {\n  const state = getState(chart);\n  let min = 1;\n  let max = 1;\n  each(chart.scales, function (scale) {\n    const origRange = getOriginalRange(state, scale.id);\n    if (origRange) {\n      const level = Math.round(origRange / (scale.max - scale.min) * 100) / 100;\n      min = Math.min(min, level);\n      max = Math.max(max, level);\n    }\n  });\n  return min < 1 ? min : max;\n}\nfunction panScale(scale, delta, limits, state) {\n  const {\n    panDelta\n  } = state;\n  const storedDelta = panDelta[scale.id] || 0;\n  if (sign(storedDelta) === sign(delta)) {\n    delta += storedDelta;\n  }\n  const fn = panFunctions[scale.type] || panFunctions.default;\n  if (callback(fn, [scale, delta, limits])) {\n    panDelta[scale.id] = 0;\n  } else {\n    panDelta[scale.id] = delta;\n  }\n}\nfunction pan(chart, delta, enabledScales, transition = 'none') {\n  const {\n    x = 0,\n    y = 0\n  } = typeof delta === 'number' ? {\n    x: delta,\n    y: delta\n  } : delta;\n  const state = getState(chart);\n  const {\n    options: {\n      pan: panOptions,\n      limits\n    }\n  } = state;\n  const {\n    onPan\n  } = panOptions || {};\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = x !== 0;\n  const yEnabled = y !== 0;\n  each(enabledScales || chart.scales, function (scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      panScale(scale, x, limits, state);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      panScale(scale, y, limits, state);\n    }\n  });\n  chart.update(transition);\n  callback(onPan, [{\n    chart\n  }]);\n}\nfunction getInitialScaleBounds(chart) {\n  const state = getState(chart);\n  storeOriginalScaleLimits(chart, state);\n  const scaleBounds = {};\n  for (const scaleId of Object.keys(chart.scales)) {\n    const {\n      min,\n      max\n    } = state.originalScaleLimits[scaleId] || {\n      min: {},\n      max: {}\n    };\n    scaleBounds[scaleId] = {\n      min: min.scale,\n      max: max.scale\n    };\n  }\n  return scaleBounds;\n}\nfunction getZoomedScaleBounds(chart) {\n  const state = getState(chart);\n  const scaleBounds = {};\n  for (const scaleId of Object.keys(chart.scales)) {\n    scaleBounds[scaleId] = state.updatedScaleLimits[scaleId];\n  }\n  return scaleBounds;\n}\nfunction isZoomedOrPanned(chart) {\n  const scaleBounds = getInitialScaleBounds(chart);\n  for (const scaleId of Object.keys(chart.scales)) {\n    const {\n      min: originalMin,\n      max: originalMax\n    } = scaleBounds[scaleId];\n    if (originalMin !== undefined && chart.scales[scaleId].min !== originalMin) {\n      return true;\n    }\n    if (originalMax !== undefined && chart.scales[scaleId].max !== originalMax) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isZoomingOrPanning(chart) {\n  const state = getState(chart);\n  return state.panning || state.dragging;\n}\nconst clamp = (x, from, to) => Math.min(to, Math.max(from, x));\nfunction removeHandler(chart, type) {\n  const {\n    handlers\n  } = getState(chart);\n  const handler = handlers[type];\n  if (handler && handler.target) {\n    handler.target.removeEventListener(type, handler);\n    delete handlers[type];\n  }\n}\nfunction addHandler(chart, target, type, handler) {\n  const {\n    handlers,\n    options\n  } = getState(chart);\n  const oldHandler = handlers[type];\n  if (oldHandler && oldHandler.target === target) {\n    return;\n  }\n  removeHandler(chart, type);\n  handlers[type] = event => handler(chart, event, options);\n  handlers[type].target = target;\n  const passive = type === 'wheel' ? false : undefined;\n  target.addEventListener(type, handlers[type], {\n    passive\n  });\n}\nfunction mouseMove(chart, event) {\n  const state = getState(chart);\n  if (state.dragStart) {\n    state.dragging = true;\n    state.dragEnd = event;\n    chart.update('none');\n  }\n}\nfunction keyDown(chart, event) {\n  const state = getState(chart);\n  if (!state.dragStart || event.key !== 'Escape') {\n    return;\n  }\n  removeHandler(chart, 'keydown');\n  state.dragging = false;\n  state.dragStart = state.dragEnd = null;\n  chart.update('none');\n}\nfunction getPointPosition(event, chart) {\n  if (event.target !== chart.canvas) {\n    const canvasArea = chart.canvas.getBoundingClientRect();\n    return {\n      x: event.clientX - canvasArea.left,\n      y: event.clientY - canvasArea.top\n    };\n  }\n  return getRelativePosition(event, chart);\n}\nfunction zoomStart(chart, event, zoomOptions) {\n  const {\n    onZoomStart,\n    onZoomRejected\n  } = zoomOptions;\n  if (onZoomStart) {\n    const point = getPointPosition(event, chart);\n    if (callback(onZoomStart, [{\n      chart,\n      event,\n      point\n    }]) === false) {\n      callback(onZoomRejected, [{\n        chart,\n        event\n      }]);\n      return false;\n    }\n  }\n}\nfunction mouseDown(chart, event) {\n  if (chart.legend) {\n    const point = getRelativePosition(event, chart);\n    if (_isPointInArea(point, chart.legend)) {\n      return;\n    }\n  }\n  const state = getState(chart);\n  const {\n    pan: panOptions,\n    zoom: zoomOptions = {}\n  } = state.options;\n  if (event.button !== 0 || keyPressed(getModifierKey(panOptions), event) || keyNotPressed(getModifierKey(zoomOptions.drag), event)) {\n    return callback(zoomOptions.onZoomRejected, [{\n      chart,\n      event\n    }]);\n  }\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n  state.dragStart = event;\n  addHandler(chart, chart.canvas.ownerDocument, 'mousemove', mouseMove);\n  addHandler(chart, window.document, 'keydown', keyDown);\n}\nfunction applyAspectRatio({\n  begin,\n  end\n}, aspectRatio) {\n  let width = end.x - begin.x;\n  let height = end.y - begin.y;\n  const ratio = Math.abs(width / height);\n  if (ratio > aspectRatio) {\n    width = Math.sign(width) * Math.abs(height * aspectRatio);\n  } else if (ratio < aspectRatio) {\n    height = Math.sign(height) * Math.abs(width / aspectRatio);\n  }\n  end.x = begin.x + width;\n  end.y = begin.y + height;\n}\nfunction applyMinMaxProps(rect, chartArea, points, {\n  min,\n  max,\n  prop\n}) {\n  rect[min] = clamp(Math.min(points.begin[prop], points.end[prop]), chartArea[min], chartArea[max]);\n  rect[max] = clamp(Math.max(points.begin[prop], points.end[prop]), chartArea[min], chartArea[max]);\n}\nfunction getRelativePoints(chart, pointEvents, maintainAspectRatio) {\n  const points = {\n    begin: getPointPosition(pointEvents.dragStart, chart),\n    end: getPointPosition(pointEvents.dragEnd, chart)\n  };\n  if (maintainAspectRatio) {\n    const aspectRatio = chart.chartArea.width / chart.chartArea.height;\n    applyAspectRatio(points, aspectRatio);\n  }\n  return points;\n}\nfunction computeDragRect(chart, mode, pointEvents, maintainAspectRatio) {\n  const xEnabled = directionEnabled(mode, 'x', chart);\n  const yEnabled = directionEnabled(mode, 'y', chart);\n  const {\n    top,\n    left,\n    right,\n    bottom,\n    width: chartWidth,\n    height: chartHeight\n  } = chart.chartArea;\n  const rect = {\n    top,\n    left,\n    right,\n    bottom\n  };\n  const points = getRelativePoints(chart, pointEvents, maintainAspectRatio && xEnabled && yEnabled);\n  if (xEnabled) {\n    applyMinMaxProps(rect, chart.chartArea, points, {\n      min: 'left',\n      max: 'right',\n      prop: 'x'\n    });\n  }\n  if (yEnabled) {\n    applyMinMaxProps(rect, chart.chartArea, points, {\n      min: 'top',\n      max: 'bottom',\n      prop: 'y'\n    });\n  }\n  const width = rect.right - rect.left;\n  const height = rect.bottom - rect.top;\n  return {\n    ...rect,\n    width,\n    height,\n    zoomX: xEnabled && width ? 1 + (chartWidth - width) / chartWidth : 1,\n    zoomY: yEnabled && height ? 1 + (chartHeight - height) / chartHeight : 1\n  };\n}\nfunction mouseUp(chart, event) {\n  const state = getState(chart);\n  if (!state.dragStart) {\n    return;\n  }\n  removeHandler(chart, 'mousemove');\n  const {\n    mode,\n    onZoomComplete,\n    drag: {\n      threshold = 0,\n      maintainAspectRatio\n    }\n  } = state.options.zoom;\n  const rect = computeDragRect(chart, mode, {\n    dragStart: state.dragStart,\n    dragEnd: event\n  }, maintainAspectRatio);\n  const distanceX = directionEnabled(mode, 'x', chart) ? rect.width : 0;\n  const distanceY = directionEnabled(mode, 'y', chart) ? rect.height : 0;\n  const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\n  state.dragStart = state.dragEnd = null;\n  if (distance <= threshold) {\n    state.dragging = false;\n    chart.update('none');\n    return;\n  }\n  zoomRect(chart, {\n    x: rect.left,\n    y: rect.top\n  }, {\n    x: rect.right,\n    y: rect.bottom\n  }, 'zoom', 'drag');\n  state.dragging = false;\n  state.filterNextClick = true;\n  callback(onZoomComplete, [{\n    chart\n  }]);\n}\nfunction wheelPreconditions(chart, event, zoomOptions) {\n  if (keyNotPressed(getModifierKey(zoomOptions.wheel), event)) {\n    callback(zoomOptions.onZoomRejected, [{\n      chart,\n      event\n    }]);\n    return;\n  }\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n  if (event.cancelable) {\n    event.preventDefault();\n  }\n  if (event.deltaY === undefined) {\n    return;\n  }\n  return true;\n}\nfunction wheel(chart, event) {\n  const {\n    handlers: {\n      onZoomComplete\n    },\n    options: {\n      zoom: zoomOptions\n    }\n  } = getState(chart);\n  if (!wheelPreconditions(chart, event, zoomOptions)) {\n    return;\n  }\n  const rect = event.target.getBoundingClientRect();\n  const speed = zoomOptions.wheel.speed;\n  const percentage = event.deltaY >= 0 ? 2 - 1 / (1 - speed) : 1 + speed;\n  const amount = {\n    x: percentage,\n    y: percentage,\n    focalPoint: {\n      x: event.clientX - rect.left,\n      y: event.clientY - rect.top\n    }\n  };\n  zoom(chart, amount, 'zoom', 'wheel');\n  callback(onZoomComplete, [{\n    chart\n  }]);\n}\nfunction addDebouncedHandler(chart, name, handler, delay) {\n  if (handler) {\n    getState(chart).handlers[name] = debounce(() => callback(handler, [{\n      chart\n    }]), delay);\n  }\n}\nfunction addListeners(chart, options) {\n  const canvas = chart.canvas;\n  const {\n    wheel: wheelOptions,\n    drag: dragOptions,\n    onZoomComplete\n  } = options.zoom;\n  if (wheelOptions.enabled) {\n    addHandler(chart, canvas, 'wheel', wheel);\n    addDebouncedHandler(chart, 'onZoomComplete', onZoomComplete, 250);\n  } else {\n    removeHandler(chart, 'wheel');\n  }\n  if (dragOptions.enabled) {\n    addHandler(chart, canvas, 'mousedown', mouseDown);\n    addHandler(chart, canvas.ownerDocument, 'mouseup', mouseUp);\n  } else {\n    removeHandler(chart, 'mousedown');\n    removeHandler(chart, 'mousemove');\n    removeHandler(chart, 'mouseup');\n    removeHandler(chart, 'keydown');\n  }\n}\nfunction removeListeners(chart) {\n  removeHandler(chart, 'mousedown');\n  removeHandler(chart, 'mousemove');\n  removeHandler(chart, 'mouseup');\n  removeHandler(chart, 'wheel');\n  removeHandler(chart, 'click');\n  removeHandler(chart, 'keydown');\n}\nfunction createEnabler(chart, state) {\n  return function (recognizer, event) {\n    const {\n      pan: panOptions,\n      zoom: zoomOptions = {}\n    } = state.options;\n    if (!panOptions || !panOptions.enabled) {\n      return false;\n    }\n    const srcEvent = event && event.srcEvent;\n    if (!srcEvent) {\n      return true;\n    }\n    if (!state.panning && event.pointerType === 'mouse' && (keyNotPressed(getModifierKey(panOptions), srcEvent) || keyPressed(getModifierKey(zoomOptions.drag), srcEvent))) {\n      callback(panOptions.onPanRejected, [{\n        chart,\n        event\n      }]);\n      return false;\n    }\n    return true;\n  };\n}\nfunction pinchAxes(p0, p1) {\n  const pinchX = Math.abs(p0.clientX - p1.clientX);\n  const pinchY = Math.abs(p0.clientY - p1.clientY);\n  const p = pinchX / pinchY;\n  let x, y;\n  if (p > 0.3 && p < 1.7) {\n    x = y = true;\n  } else if (pinchX > pinchY) {\n    x = true;\n  } else {\n    y = true;\n  }\n  return {\n    x,\n    y\n  };\n}\nfunction handlePinch(chart, state, e) {\n  if (state.scale) {\n    const {\n      center,\n      pointers\n    } = e;\n    const zoomPercent = 1 / state.scale * e.scale;\n    const rect = e.target.getBoundingClientRect();\n    const pinch = pinchAxes(pointers[0], pointers[1]);\n    const mode = state.options.zoom.mode;\n    const amount = {\n      x: pinch.x && directionEnabled(mode, 'x', chart) ? zoomPercent : 1,\n      y: pinch.y && directionEnabled(mode, 'y', chart) ? zoomPercent : 1,\n      focalPoint: {\n        x: center.x - rect.left,\n        y: center.y - rect.top\n      }\n    };\n    zoom(chart, amount, 'zoom', 'pinch');\n    state.scale = e.scale;\n  }\n}\nfunction startPinch(chart, state, event) {\n  if (state.options.zoom.pinch.enabled) {\n    const point = getRelativePosition(event, chart);\n    if (callback(state.options.zoom.onZoomStart, [{\n      chart,\n      event,\n      point\n    }]) === false) {\n      state.scale = null;\n      callback(state.options.zoom.onZoomRejected, [{\n        chart,\n        event\n      }]);\n    } else {\n      state.scale = 1;\n    }\n  }\n}\nfunction endPinch(chart, state, e) {\n  if (state.scale) {\n    handlePinch(chart, state, e);\n    state.scale = null;\n    callback(state.options.zoom.onZoomComplete, [{\n      chart\n    }]);\n  }\n}\nfunction handlePan(chart, state, e) {\n  const delta = state.delta;\n  if (delta) {\n    state.panning = true;\n    pan(chart, {\n      x: e.deltaX - delta.x,\n      y: e.deltaY - delta.y\n    }, state.panScales);\n    state.delta = {\n      x: e.deltaX,\n      y: e.deltaY\n    };\n  }\n}\nfunction startPan(chart, state, event) {\n  const {\n    enabled,\n    onPanStart,\n    onPanRejected\n  } = state.options.pan;\n  if (!enabled) {\n    return;\n  }\n  const rect = event.target.getBoundingClientRect();\n  const point = {\n    x: event.center.x - rect.left,\n    y: event.center.y - rect.top\n  };\n  if (callback(onPanStart, [{\n    chart,\n    event,\n    point\n  }]) === false) {\n    return callback(onPanRejected, [{\n      chart,\n      event\n    }]);\n  }\n  state.panScales = getEnabledScalesByPoint(state.options.pan, point, chart);\n  state.delta = {\n    x: 0,\n    y: 0\n  };\n  handlePan(chart, state, event);\n}\nfunction endPan(chart, state) {\n  state.delta = null;\n  if (state.panning) {\n    state.panning = false;\n    state.filterNextClick = true;\n    callback(state.options.pan.onPanComplete, [{\n      chart\n    }]);\n  }\n}\nconst hammers = new WeakMap();\nfunction startHammer(chart, options) {\n  const state = getState(chart);\n  const canvas = chart.canvas;\n  const {\n    pan: panOptions,\n    zoom: zoomOptions\n  } = options;\n  const mc = new Hammer.Manager(canvas);\n  if (zoomOptions && zoomOptions.pinch.enabled) {\n    mc.add(new Hammer.Pinch());\n    mc.on('pinchstart', e => startPinch(chart, state, e));\n    mc.on('pinch', e => handlePinch(chart, state, e));\n    mc.on('pinchend', e => endPinch(chart, state, e));\n  }\n  if (panOptions && panOptions.enabled) {\n    mc.add(new Hammer.Pan({\n      threshold: panOptions.threshold,\n      enable: createEnabler(chart, state)\n    }));\n    mc.on('panstart', e => startPan(chart, state, e));\n    mc.on('panmove', e => handlePan(chart, state, e));\n    mc.on('panend', () => endPan(chart, state));\n  }\n  hammers.set(chart, mc);\n}\nfunction stopHammer(chart) {\n  const mc = hammers.get(chart);\n  if (mc) {\n    mc.remove('pinchstart');\n    mc.remove('pinch');\n    mc.remove('pinchend');\n    mc.remove('panstart');\n    mc.remove('pan');\n    mc.remove('panend');\n    mc.destroy();\n    hammers.delete(chart);\n  }\n}\nfunction hammerOptionsChanged(oldOptions, newOptions) {\n  const {\n    pan: oldPan,\n    zoom: oldZoom\n  } = oldOptions;\n  const {\n    pan: newPan,\n    zoom: newZoom\n  } = newOptions;\n  if (oldZoom?.zoom?.pinch?.enabled !== newZoom?.zoom?.pinch?.enabled) {\n    return true;\n  }\n  if (oldPan?.enabled !== newPan?.enabled) {\n    return true;\n  }\n  if (oldPan?.threshold !== newPan?.threshold) {\n    return true;\n  }\n  return false;\n}\nvar version = \"2.2.0\";\nfunction draw(chart, caller, options) {\n  const dragOptions = options.zoom.drag;\n  const {\n    dragStart,\n    dragEnd\n  } = getState(chart);\n  if (dragOptions.drawTime !== caller || !dragEnd) {\n    return;\n  }\n  const {\n    left,\n    top,\n    width,\n    height\n  } = computeDragRect(chart, options.zoom.mode, {\n    dragStart,\n    dragEnd\n  }, dragOptions.maintainAspectRatio);\n  const ctx = chart.ctx;\n  ctx.save();\n  ctx.beginPath();\n  ctx.fillStyle = dragOptions.backgroundColor || 'rgba(225,225,225,0.3)';\n  ctx.fillRect(left, top, width, height);\n  if (dragOptions.borderWidth > 0) {\n    ctx.lineWidth = dragOptions.borderWidth;\n    ctx.strokeStyle = dragOptions.borderColor || 'rgba(225,225,225)';\n    ctx.strokeRect(left, top, width, height);\n  }\n  ctx.restore();\n}\nvar plugin = {\n  id: 'zoom',\n  version,\n  defaults: {\n    pan: {\n      enabled: false,\n      mode: 'xy',\n      threshold: 10,\n      modifierKey: null\n    },\n    zoom: {\n      wheel: {\n        enabled: false,\n        speed: 0.1,\n        modifierKey: null\n      },\n      drag: {\n        enabled: false,\n        drawTime: 'beforeDatasetsDraw',\n        modifierKey: null\n      },\n      pinch: {\n        enabled: false\n      },\n      mode: 'xy'\n    }\n  },\n  start: function (chart, _args, options) {\n    const state = getState(chart);\n    state.options = options;\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'enabled')) {\n      console.warn('The option `zoom.enabled` is no longer supported. Please use `zoom.wheel.enabled`, `zoom.drag.enabled`, or `zoom.pinch.enabled`.');\n    }\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'overScaleMode') || Object.prototype.hasOwnProperty.call(options.pan, 'overScaleMode')) {\n      console.warn('The option `overScaleMode` is deprecated. Please use `scaleMode` instead (and update `mode` as desired).');\n    }\n    if (Hammer) {\n      startHammer(chart, options);\n    }\n    chart.pan = (delta, panScales, transition) => pan(chart, delta, panScales, transition);\n    chart.zoom = (args, transition) => zoom(chart, args, transition);\n    chart.zoomRect = (p0, p1, transition) => zoomRect(chart, p0, p1, transition);\n    chart.zoomScale = (id, range, transition) => zoomScale(chart, id, range, transition);\n    chart.resetZoom = transition => resetZoom(chart, transition);\n    chart.getZoomLevel = () => getZoomLevel(chart);\n    chart.getInitialScaleBounds = () => getInitialScaleBounds(chart);\n    chart.getZoomedScaleBounds = () => getZoomedScaleBounds(chart);\n    chart.isZoomedOrPanned = () => isZoomedOrPanned(chart);\n    chart.isZoomingOrPanning = () => isZoomingOrPanning(chart);\n  },\n  beforeEvent(chart, {\n    event\n  }) {\n    if (isZoomingOrPanning(chart)) {\n      return false;\n    }\n    if (event.type === 'click' || event.type === 'mouseup') {\n      const state = getState(chart);\n      if (state.filterNextClick) {\n        state.filterNextClick = false;\n        return false;\n      }\n    }\n  },\n  beforeUpdate: function (chart, args, options) {\n    const state = getState(chart);\n    const previousOptions = state.options;\n    state.options = options;\n    if (hammerOptionsChanged(previousOptions, options)) {\n      stopHammer(chart);\n      startHammer(chart, options);\n    }\n    addListeners(chart, options);\n  },\n  beforeDatasetsDraw(chart, _args, options) {\n    draw(chart, 'beforeDatasetsDraw', options);\n  },\n  afterDatasetsDraw(chart, _args, options) {\n    draw(chart, 'afterDatasetsDraw', options);\n  },\n  beforeDraw(chart, _args, options) {\n    draw(chart, 'beforeDraw', options);\n  },\n  afterDraw(chart, _args, options) {\n    draw(chart, 'afterDraw', options);\n  },\n  stop: function (chart) {\n    removeListeners(chart);\n    if (Hammer) {\n      stopHammer(chart);\n    }\n    removeState(chart);\n  },\n  panFunctions,\n  zoomFunctions,\n  zoomRectFunctions\n};\nexport { plugin as default, pan, resetZoom, zoom, zoomRect, zoomScale };"],
  "mappings": "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",
  "names": ["window", "document", "undefined", "each", "assign", "extend", "merge", "callback", "self", "getCenter", "Hammer", "debounce", "zoom", "pan", "Hammer"]
}
